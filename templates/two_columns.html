
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Prototype</title>
    <style>
        body {background-color: powderblue;}
        h1 {color: blue;}
        p {color: red;}
        .columns {display: flex; flex-direction: row; flex-wrap: wrap; width: 100%; }
        .column {flex: 50%;}
    </style>
    </head>
<body>
<div class="columns">
<div class="column">
    {% raw scr %}
</div>
<div class="column">
    <div id="message" style="display:block">
        <p id="text" style="font-family:'Courier New';color:red;">
            <p>Welcome to the prototype of MasonDixon.</p>

            <p>In all fields of data visualization, many challenges stem from plots that are technically accurate but misleading. This algorithm specifically addresses one such challenge in Geospatial data analysis.</p>
			
			<p>When colouring a map according to a variable (for example, per capita income or the average cost of a hotel per region), it is not trivial to divide a map optimally. On the one hand, we do not want too many large regions without cities. Conversely, if too many cities or population centres are bunched into a single region, it can skew statistics and make the map misleading.</p>

            <p>MasonDixon is a geographic engine that combines geospatial, mathematical, and statistical methods to divide maps on the fly, for example when the user is zooming and panning. This app demonstrates one such algorithm; as the user zooms and pans on the map, the algorithm divides the field of view into regions in such a way that there are not too many population centres in a single region of the map. The regions are then overlaid on the map.</p>

            <p>At the back-end, a database contains a list of (latitude, longitude) pairs, for example a list of global cities, hotels, offices, etc. A numerical value is applied to each entry in the list, and an aggregating function (usually linear regression or population-weighting) is used to determine the aggregate value for the region. After every update, the new regions are drawn on the map and the colouring is updated accordingly.</p>

			<p>These values are updated asynchronously (e.g. via a web API call). For example, MasonDixon could be used to build an app that dynamically scrapes the average fare to fly to an airport or the average price of a hotel room in a city. Currently there is a database of mock data at the back end, of global city coordinates and values. Although the map is rendered using WebMercator coordinates, the database coordinates are stored as WGS84 values, as this is standard for most web APIs. This database is called asynchronously, and clicking the button will add random noise to these values. (The colouring will automatically update).</p>

            <p>Dataset is Natural Earth</p>
        </p>
    </div>
    <form id="updater" action="http://localhost:8888/click" method="post">
        <!--p>Magnitude of noise of data:<input type="number" name="variance" /></p-->
        <p><input type="submit" value="submit"/></p>
    </form>
<!--form id="updater" action="http://localhost:8888/click" method="post">
  <button type="submit">
      Update on next cycle
  </button>
</form-->
</div>
</div>

<script>
    function collectData(currentForm) {
        return new FormData(currentForm);
    }

    function setOptions(currentForm) {
        return { method: 'post', body: collectData(currentForm) };
    }

    function sendForm(currentForm) {
        return fetch(currentForm.action, setOptions(currentForm));
    }

    function onSubmit(event) {
        event.preventDefault();
        const { currentTarget } = event;
        sendForm(currentTarget);
    }

    form = document.getElementById('updater');
    form.addEventListener('submit', onSubmit);

    // Maybe overkill, since it fires when navigating out/refreshing
    window.onbeforeunload = closingCode;
    function closingCode() {
        fetch("http://localhost:8888/exit", { method: 'post', body: {} })
        return null;
    }
</script>

</body>
</html>